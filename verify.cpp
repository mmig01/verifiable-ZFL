#include <iostream>
#include <vector>
#include <cstdint>
#include <chrono>
#include <random>
#include <stdexcept>
#include <string>
#include <numeric> // std::accumulate

// GMP C++ header
#include <gmpxx.h>

/**
 * @brief Generates a random mpz_class integer of a specific bit length using GMP.
 */
mpz_class generate_random_by_bits_gmp(unsigned long bits, gmp_randstate_t& rand_state) {
    if (bits == 0) return 0;
    mpz_class random_num;
    mpz_urandomb(random_num.get_mpz_t(), rand_state, bits);
    if (bits > 1) {
        mpz_setbit(random_num.get_mpz_t(), bits - 1);
    }
    return random_num;
}

/**
 * @brief Performs a safe modulo operation for mpz_class, ensuring a non-negative result.
 */
mpz_class safe_mod(const mpz_class& a, const mpz_class& m) {
    return (a % m + m) % m;
}

/**
 * @brief Evaluates a polynomial at a specific value x using GMP (polyval).
 */
mpz_class polyval_gmp(const std::vector<mpz_class>& poly, const mpz_class& x, const mpz_class& q) {
    mpz_class result = 0;
    for (int i = poly.size() - 1; i >= 0; --i) {
        result = safe_mod(result * x + poly[i], q);
    }
    return result;
}

int main() {
    try {
        // --- 1. Parameter Setup ---
        const int q_bits = 120;
        const int alpha_bits = 120;
        const size_t n_clients = 100;
        const size_t ki = 262144;

        // --- Initialize GMP Random State ---
        gmp_randstate_t rand_state;
        gmp_randinit_default(rand_state);
        std::random_device rd;
        gmp_randseed_ui(rand_state, rd());

        const mpz_class q = generate_random_by_bits_gmp(q_bits, rand_state);
        const mpz_class alpha = generate_random_by_bits_gmp(alpha_bits, rand_state);

        // --- 2. Generate Random Values for Verification ---
        
        auto start = std::chrono::high_resolution_clock::now();

        // Simulate the 'client_calc_r' values generated by each client
        std::vector<mpz_class> client_calc_r_values(n_clients);
        mpz_class r0_sum = 0;
        for (size_t c = 0; c < n_clients; ++c) {
            mpz_urandomm(client_calc_r_values[c].get_mpz_t(), rand_state, q.get_mpz_t());
            r0_sum += client_calc_r_values[c];
        }
        r0_sum = safe_mod(r0_sum, q);
    

        mpz_class sum_of_u_r0;
        mpz_urandomm(sum_of_u_r0.get_mpz_t(), rand_state, q.get_mpz_t());

        std::vector<mpz_class> mul_of_b_r0(ki);
        for (size_t k = 0; k < ki; ++k) {
            mpz_urandomm(mul_of_b_r0[k].get_mpz_t(), rand_state, q.get_mpz_t());
        }

        std::vector<mpz_class> R_t_poly(2);
        mpz_urandomm(R_t_poly[0].get_mpz_t(), rand_state, q.get_mpz_t());
        mpz_urandomm(R_t_poly[1].get_mpz_t(), rand_state, q.get_mpz_t());

        std::cout << "Starting C++ final proof verification simulation..." << std::endl;

        // --- 3. Implement the Final Verification Logic ---
        // Right-hand side of the proof (calculated by the Verifier)
        mpz_class sum_of_b_t = 0;
        for (size_t k = 0; k < ki; ++k) {
            sum_of_b_t += mul_of_b_r0[k];
        }

        mpz_class sum_of_u_r0_plus_sum_of_b_t = safe_mod(sum_of_u_r0 + sum_of_b_t, q);
        mpz_class eval_R_at_r0 = polyval_gmp(R_t_poly, r0_sum, q);
        mpz_class sub_result = safe_mod(sum_of_u_r0_plus_sum_of_b_t - eval_R_at_r0, q);
        mpz_class result = safe_mod(alpha * sub_result, q);

        // To ensure validation success, set the client values so that the final F_log2m_r0 equals 'result'
        std::vector<mpz_class> client_F_values(n_clients);
        mpz_class temp_F_sum = 0;

        // Generate random values for n-1 clients
        for (size_t c = 0; c < n_clients - 1; ++c) {
            mpz_urandomm(client_F_values[c].get_mpz_t(), rand_state, q.get_mpz_t());
            temp_F_sum += client_F_values[c];
        }
        
        // The last client's value is calculated as (target_value - current_sum) to make the total sum match 'result'
        client_F_values[n_clients - 1] = safe_mod(result - temp_F_sum, q);

        // Calculate the final F_log2m_r0 as the sum of all client values
        mpz_class F_log2m_r0 = 0;
        for (const auto& val : client_F_values) {
            F_log2m_r0 += val;
        }
        F_log2m_r0 = safe_mod(F_log2m_r0, q);
       

        // --- 4. Output Results and Verification ---
        std::cout << "--------------------------------------------------------" << std::endl;
        std::cout << "Left Hand Side (Sum of client F values):  " << F_log2m_r0 << std::endl;
        std::cout << "Right Hand Side (Calculated by Verifier): " << result << std::endl;
        std::cout << "--------------------------------------------------------" << std::endl;

        if (F_log2m_r0 == result) {
            std::cout << "Validation Success: The values match." << std::endl;
        } else {
            std::cout << "Validation Failed: The values do not match." << std::endl;
        }
        std::cout << "--------------------------------------------------------" << std::endl;
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "C++ (ZKP Logic): Time taken for final proof verification simulation: " 
                  << duration.count() << " ms" << std::endl;
        std::cout << "--------------------------------------------------------" << std::endl;
        gmp_randclear(rand_state);

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
